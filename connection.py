import psutil
from ipwhois import IPWhois
import socket
import const
import danger_counter
from virustotal3 import core
import config
from colorama import Fore
from colorama import Style
import os


class ProcessConnection:
    def __init__(self):
        self.exists_connection = []
        self.pid_connection = []
        self.ip_info = {}
        self.__init_connection()

    def __init_connection(self):
        print('[init check connection...]')
        listPid = psutil.pids()

        for pid in listPid:
            try:
                conns = psutil.Process(pid).connections()
                for c in conns:
                    if not (pid, c.raddr) in self.exists_connection and\
                            c.raddr != ():
                        self.exists_connection.append((pid, c.raddr))
            finally:
                continue

    def check_new_connection(self):
        list_pid = psutil.pids()
        for pid in list_pid:
            if pid in danger_counter.danger_counter:
                self.check_connection_by_pid(pid)

#    @staticmethod
    def check_connection_by_pid(self, pid):
        try:
            conns = psutil.Process(pid).connections()
            for c in conns:
                if pid not in self.pid_connection:
                    self.pid_connection.append(pid)

                if not (pid, c.raddr) in self.exists_connection and \
                        c.raddr != ():
                    self.exists_connection.append((pid, c.raddr))
                    self.__fill_ip_info(c.raddr.ip)
                    print(f'{Fore.MAGENTA}[{pid}][{c.raddr.ip}][{c.raddr.port}][asn]: ' +
                          f'{self.ip_info[c.raddr.ip]["asn"]}{Style.RESET_ALL}')
                    print(f'{Fore.MAGENTA}[{pid}][{c.raddr.ip}][{c.raddr.port}][asn country code]: ' +
                          f'{self.ip_info[c.raddr.ip]["asn_country_code"]}{Style.RESET_ALL}')
                    print(f'{Fore.MAGENTA}[{pid}][{c.raddr.ip}][{c.raddr.port}][domain]: ' +
                          f'{self.ip_info[c.raddr.ip]["domain"]}{Style.RESET_ALL}')

                    malicious_points = self.__check_danger(c.raddr.ip)
                    if malicious_points > 0:
                        if not os.path.exists(f'C:\\tasks\\analysis\\{pid}'):
                            os.mkdir(f'C:\\tasks\\analysis\\{pid}')
                        danger_counter.add(pid, malicious_points)
                        danger_counter.add_details(pid, const.DANGER_CONNECTION)
                        print(f'{Fore.RED}[{pid}][{c.raddr.ip}][{c.raddr.port}][VirusTotal]: ' +
                              f'{malicious_points}{Style.RESET_ALL}')
                    else:
                        print(f'{Fore.MAGENTA}[{pid}][{c.raddr.ip}][{c.raddr.port}][VirusTotal]: ' +
                              f'{malicious_points}{Style.RESET_ALL}')
        finally:
            return

    def __fill_ip_info(self, ip):
        if ip not in self.ip_info.keys():
            try:
                obj = IPWhois(ip)
                res = obj.lookup_whois()
                try:
                    domain = socket.gethostbyaddr(ip)
                    res['domain'] = domain[0]
                except:
                    res['domain'] = ip
                self.ip_info[ip] = res
            finally:
                return

    @staticmethod
    def __check_danger(ip):
        vt = core.IP(config.API_KEY)
        result = vt.info_ip(ip=ip, timeout=500)
        last_analysis_stats = result['data']['attributes']['last_analysis_stats']
        malicious_points = last_analysis_stats['malicious']
        return malicious_points
