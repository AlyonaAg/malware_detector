import pefile
from signify.authenticode import SignedPEFile
from signify.authenticode import AuthenticodeVerificationResult
import const
import sys
import datetime
import os
import peutils
import psutil
import danger_counter


class ProcessAnalysis:
    @staticmethod
    def new_process(pid):
        try:
            p = psutil.Process(pid)
            print('[new process]:')
            print(f'  [name]: {p.name()}\n    [pid]: {pid}')
            pe = PE(p)
            pe.analysis()
        finally:
            return

    # @staticmethod
    def check_new_process_hook(self, pid):
        try:
            process = psutil.Process(pid)
            pe = PE(process)
            pe.analysis()
        finally:
            return

    @staticmethod
    def del_process(pid):
        print('[deleted processes]:')
        print(f'  [pid]: {pid}')


class PE:
    def __init__(self, process, print_to_file=True):
        self.pid = process.pid
        self.process_name = process.name()
        self.pe = pefile.PE(process.exe())
        self.filename = process.exe()
        self.parent = process.parent().pid
        self.print_to_file = print_to_file
        self.output_file = sys.stdout

    def analysis(self):
        try:
            if self.print_to_file:
                self.output_file = open(self.__format_filename(), 'w+')
            self.check_pid()
            self.check_parent()
            self.check_section()
            self.check_peid_signatures()
            self.check_imported_symbols()
            self.has_cert()
        finally:
            self.output_file.close()

    def check_pid(self):
        self.__print(f'[pid]: {self.pid}')

    def check_parent(self):
        self.__print(f'[parent pid]: {self.parent}')

    def check_section(self):
        self.__print('[section]:')
        for idx, section_entry in enumerate(self.pe.sections):
            name = section_entry.Name.decode('utf-8')
            self.__print('  [name]:', name)
            self.__print('    [characteristics]:')
            self.__parse_section_characteristic(section_entry.Characteristics)
            self.__print('    [md5]:', section_entry.get_hash_md5())
            self.__print('    [entropy]:', section_entry.get_entropy())

    def __parse_section_characteristic(self, characteristics):
        if characteristics & const.IMAGE_SCN_CNT_CODE:
            self.__print('      [-] section contains executable code')
        if characteristics & const.IMAGE_SCN_CNT_INITIALIZED_DATA:
            self.__print('      [-] section contains initialized data')
        if characteristics & const.IMAGE_SCN_CNT_UNINITIALIZED_DATA:
            self.__print('      [-] section contains uninitialized data')
        if characteristics & const.IMAGE_SCN_MEM_DISCARDABLE:
            self.__print('      [-] section can be discarded as needed')
        if characteristics & const.IMAGE_SCN_MEM_NOT_CACHED:
            self.__print('      [-] section cannot be cached')
        if characteristics & const.IMAGE_SCN_MEM_NOT_PAGED:
            self.__print('      [-] section cannot be paged')
        if characteristics & const.IMAGE_SCN_MEM_SHARED:
            self.__print('      [-] section can be shared in memory')
        if characteristics & const.IMAGE_SCN_MEM_EXECUTE:
            self.__print('      [-] section can be executed as code')
        if characteristics & const.IMAGE_SCN_MEM_READ:
            self.__print('      [-] section can be read')
        if characteristics & const.IMAGE_SCN_MEM_WRITE:
            self.__print('      [-] section can be written to')
        if (characteristics & const.IMAGE_SCN_MEM_EXECUTE) and \
                (characteristics & const.IMAGE_SCN_MEM_WRITE):
            self.__print('      [!] section is available for both write and execute')
            danger_counter.add(self.pid, const.SUSPICIOUS_SECTION_POINT)
            print(f'    [!][{self.process_name}] contains section is available for both write and execute')

    def check_peid_signatures(self):
        self.__print('[pack]:')

        sig_path = os.path.join(os.getcwd() + "\\UserDB.TXT")
        with open(sig_path, 'rt') as f:
            sig_data = f.read()
            signatures = peutils.SignatureDatabase(data=sig_data)
        signs = signatures.match(self.pe, ep_only=True)

        if signs is None:
            self.__print('  [-] not detected')
        else:
            danger_counter.add(self.pid, const.PACKER_POINT)
            print(f'    [!][{self.process_name}] file may be packed')
            for s in signs:
                self.__print('  [!]', s)

    def check_imported_symbols(self):
        self.__print('[import]:')

        imports = []

        for entry in getattr(self.pe, "DIRECTORY_ENTRY_IMPORT", []):
            for imported_symbol in entry.imports:
                if imported_symbol.name is not None:
                    name = imported_symbol.name.decode("utf-8")
                    if name is not None and not name.startswith('_'):
                        imports.append(name)

        if len(imports) == 0:
            self.__print('  [-] no imported')
        else:
            for i in imports:
                if i in const.alerts:
                    danger_counter.add(self.pid, const.SUSPICIOUS_IMPORT_POINT)
                    print(f'    [!] imports \'{i}\'')
                    self.__print(f'  [!] {i}')
                else:
                    self.__print(f'  [-] {i}')

    def has_cert(self):
        self.__print('[signature]:')
        valid = False
        try:
            file_obj = open(self.filename, "rb")
            pe = SignedPEFile(file_obj)
            for signed_data in pe.signed_datas:
                if not valid:
                    valid = signed_data.explain_verify()[0] == AuthenticodeVerificationResult.OK
        finally:
            if not valid:
                self.__print('  [!] no certificate')
                danger_counter.add(self.pid, const.NO_SIGNATURE_POINT)
            else:
                self.__print('  [-] has valid certificate')
        is_cert_exist = (security_directory.Size and security_directory.VirtualAddress) != 0x0
        if not is_cert_exist:
            self.__print('  [!] no certificate')
            danger_counter.add(self.pid, const.NO_SIGNATURE_POINT)
        else:
            self.__print('  [-] has certificate')


    def __print(self, *args):
        print(*args, file=self.output_file)

    def __format_filename(self):
        now = datetime.datetime.now()
        date = str(now.year) + str(now.month) + str(now.day)
        time = str(now.hour) + str(now.minute) + str(now.second)
        return 'analysis\\' + date + '_' + time + '_' + self.process_name + '_' + str(self.pid) + '.analysis'
