import pefile
import const
import sys
import datetime
import os
import peutils
import psutil
import danger_counter


class ProcessAnalysis:
    def __init__(self):
        self.processes = []
        self.__init_processes()

    def __init_processes(self):
        self.processes = psutil.pids()

    def check_new_process(self):
        now_process = psutil.pids()
        new_proc = set(set(now_process)).difference(self.processes)
        del_proc = set(set(self.processes)).difference(now_process)

        if len(new_proc) > 0:
            self.processes = set(self.processes).union(now_process)

            for pid in new_proc:
                print('  [new process]:')
                p = psutil.Process(pid)
                print(f'    [name]: {p.name()}\n    [pid]: {pid}')
                pe = PE(p)
                pe.analysis()

        if len(del_proc) > 0:
            print('  [deleted processes]:')
            for pid in del_proc:
                print(f'    [pid]: {pid}')


class PE:
    def __init__(self, process, print_to_file=True):
        self.pid = process.pid
        self.process_name = process.name()
        self.pe = pefile.PE(process.exe())
        self.parent = process.parent().pid
        self.print_to_file = print_to_file
        self.output_file = sys.stdout

    def analysis(self):
        try:
            if self.print_to_file:
                self.output_file = open(self.__format_filename(self.process_name), 'w+')
            self.check_parent()
            self.check_section()
            self.check_peid_signatures()
            self.check_imported_symbols()
        finally:
            self.output_file.close()

    def check_parent(self):
        self.__print(f'[parent pid]: {self.parent}')

    def check_section(self):
        self.__print('[section]:')
        for idx, section_entry in enumerate(self.pe.sections):
            name = section_entry.Name.decode('utf-8')
            self.__print('  [name]:', name)
            self.__print('    [characteristics]:')
            self.__parse_section_characteristic(section_entry.Characteristics)
            self.__print('    [md5]:', section_entry.get_hash_md5())
            self.__print('    [entropy]:', section_entry.get_entropy())

    def __parse_section_characteristic(self, characteristics):
        if characteristics & const.IMAGE_SCN_CNT_CODE:
            self.__print('      [-] section contains executable code')
        if characteristics & const.IMAGE_SCN_CNT_INITIALIZED_DATA:
            self.__print('      [-] section contains initialized data')
        if characteristics & const.IMAGE_SCN_CNT_UNINITIALIZED_DATA:
            self.__print('      [-] section contains uninitialized data')
        if characteristics & const.IMAGE_SCN_MEM_DISCARDABLE:
            self.__print('      [-] section can be discarded as needed')
        if characteristics & const.IMAGE_SCN_MEM_NOT_CACHED:
            self.__print('      [-] section cannot be cached')
        if characteristics & const.IMAGE_SCN_MEM_NOT_PAGED:
            self.__print('      [-] section cannot be paged')
        if characteristics & const.IMAGE_SCN_MEM_SHARED:
            self.__print('      [-] section can be shared in memory')
        if characteristics & const.IMAGE_SCN_MEM_EXECUTE:
            self.__print('      [-] section can be executed as code')
        if characteristics & const.IMAGE_SCN_MEM_READ:
            self.__print('      [-] section can be read')
        if characteristics & const.IMAGE_SCN_MEM_WRITE:
            self.__print('      [-] section can be written to')
        if (characteristics & const.IMAGE_SCN_MEM_EXECUTE) and \
            (characteristics & const.IMAGE_SCN_MEM_WRITE):
            self.__print('      [!] section is available for both write and execute')
            danger_counter.add(self.pid, const.SUSPICIOUS_SECTION_POINT)
            print(f'    [!][{self.process_name}] contains section is available for both write and execute')

    def check_peid_signatures(self):
        self.__print('[pack]:')

        sig_path = os.path.join(os.getcwd() + "\\UserDB.TXT")
        with open(sig_path, 'rt') as f:
            sig_data = f.read()
            signatures = peutils.SignatureDatabase(data=sig_data)
        signs = signatures.match(self.pe, ep_only=True)

        if signs is None:
            self.__print('  [-] not detected')
        else:
            danger_counter.add(self.pid, const.PACKER_POINT)
            print(f'    [!][{self.process_name}] file may be packed')
            for s in signs:
                self.__print('  [!]', s)

    def check_imported_symbols(self):
        self.__print('[import]:')

        imports = []

        for entry in getattr(self.pe, "DIRECTORY_ENTRY_IMPORT", []):
            for imported_symbol in entry.imports:
                if imported_symbol.name is not None:
                    name = imported_symbol.name.decode("utf-8")
                    if name is not None and not name.startswith('_'):
                        imports.append(name)

        if len(imports) == 0:
            self.__print('  [-] no imported')
        else:
            for i in imports:
                if i in const.alerts:
                    danger_counter.add(self.pid, const.SUSPICIOUS_IMPORT_POINT)
                    print(f'    [!] imports \'{i}\'')
                    self.__print(f'  [!] {i}')
                else:
                    self.__print(f'  [-] {i}')

    def __print(self, *args):
        print(*args, file=self.output_file)

    @staticmethod
    def __format_filename(filename):
        now = datetime.datetime.now()
        date = str(now.year) + str(now.month) + str(now.day)
        time = str(now.hour) + str(now.minute) + str(now.second)
        return 'analysis\\' + date + '_' + time + '_' + '.'.join(filename.split('.')[:-1]) + '.analysis'
