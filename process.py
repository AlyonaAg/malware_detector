import pefile
import signify.authenticode.signed_pe
import capa
import const
import sys
import os
import peutils
import psutil
import danger_counter
import difflib
from capstone import *
from colorama import Fore
from colorama import Style


differ = difflib.Differ()
md = Cs(CS_ARCH_X86, CS_MODE_64)
processing_queue = []


class ProcessAnalysis:
    @staticmethod
    def new_process(pid):
        try:
            p = psutil.Process(pid)
            if p.name() == 'pd64.exe' or p.name() == 'capa.exe' or p.parent().pid == os.getpid():
                return
            print(f'{Fore.GREEN}[new process]: {pid}, {p.name()}{Style.RESET_ALL}')
            pe = PE(p)
            os.mkdir(f'C:\\tasks\\analysis\\{pid}')
            dump = Dump(pid)
            dump.get_dump()
            processing_queue.append([pid, pe, dump])
        finally:
            return

    @staticmethod
    def del_process(pid):
        try:
            print(f'{Fore.YELLOW}[deleted processes]: {pid}{Style.RESET_ALL}')
        finally:
            return


class PE:
    def __init__(self, process, print_to_file=True):
        self.pid = process.pid
        self.process_name = process.name()
        self.pe = pefile.PE(process.exe())
        self.filename = process.exe()
        self.parent = process.parent().pid
        self.print_to_file = print_to_file
        self.output_file = sys.stdout
        self.signed = False
        try:
            with open(self.filename, "rb") as f:
                sign = signify.authenticode.signed_pe.SignedPEFile(f)
                status, err = sign.explain_verify()
                self.signed = (status == signify.authenticode.signed_pe.AuthenticodeVerificationResult.OK)
        finally:
            return

    def analysis(self):
        if self.print_to_file:
            self.output_file = open(f'analysis\\{self.pid}\\{self.process_name}.static', 'w')

        self.check_pid()
        self.check_parent()
        self.check_exe_path()
        self.check_section()
        self.check_peid_signatures()
        self.check_imported_symbols()
        self.has_cert()

        self.output_file.close()

        if self.process_name == 'notepad.exe':
            thr = capa.CapaThread(self.filename, self.pid)
            thr.start()

    def check_exe_path(self):
        print(f'{Fore.BLUE}[{self.pid}][path to exe]: {self.filename}{Style.RESET_ALL}')
        self.__print(f'[path to exe]: {self.filename}')

    def check_pid(self):
        self.__print(f'[pid]: {self.pid}')

    def check_parent(self):
        print(f'{Fore.BLUE}[{self.pid}][parent pid]: {self.parent}{Style.RESET_ALL}')
        self.__print(f'[parent pid]: {self.parent}')

    def check_section(self):
        try:
            self.__print('[section]:')
            for idx, section_entry in enumerate(self.pe.sections):
                name = section_entry.Name.decode('utf-8').replace('\0', '')
                entropy = section_entry.get_entropy()
                self.__print('  [name]:', name)
                self.__print('    [characteristics]:')
                self.__parse_section_characteristic(section_entry.Characteristics)
                self.__print('    [md5]:', section_entry.get_hash_md5())
                self.__print('    [entropy]:', entropy)

                print(f'{Fore.BLUE}[{self.pid}][section]: {name} {round(entropy, 3)}{Style.RESET_ALL}')
        finally:
            return

    def __parse_section_characteristic(self, characteristics):
        if characteristics & const.IMAGE_SCN_CNT_CODE:
            self.__print('      [-] section contains executable code')
        if characteristics & const.IMAGE_SCN_CNT_INITIALIZED_DATA:
            self.__print('      [-] section contains initialized data')
        if characteristics & const.IMAGE_SCN_CNT_UNINITIALIZED_DATA:
            self.__print('      [-] section contains uninitialized data')
        if characteristics & const.IMAGE_SCN_MEM_DISCARDABLE:
            self.__print('      [-] section can be discarded as needed')
        if characteristics & const.IMAGE_SCN_MEM_NOT_CACHED:
            self.__print('      [-] section cannot be cached')
        if characteristics & const.IMAGE_SCN_MEM_NOT_PAGED:
            self.__print('      [-] section cannot be paged')
        if characteristics & const.IMAGE_SCN_MEM_SHARED:
            self.__print('      [-] section can be shared in memory')
        if characteristics & const.IMAGE_SCN_MEM_EXECUTE:
            self.__print('      [-] section can be executed as code')
        if characteristics & const.IMAGE_SCN_MEM_READ:
            self.__print('      [-] section can be read')
        if characteristics & const.IMAGE_SCN_MEM_WRITE:
            self.__print('      [-] section can be written to')
        if (characteristics & const.IMAGE_SCN_MEM_EXECUTE) and \
                (characteristics & const.IMAGE_SCN_MEM_WRITE):
            self.__print('      [!] section is available for both write and execute')
            danger_counter.add(self.pid, const.SUSPICIOUS_SECTION_POINT)
            danger_counter.add_details(self.pid, const.SUSPICIOUS_SECTION)
            print(f'{Fore.RED}[{self.pid}][section characteristics]:',
                  f' contains section is available for both write and execute{Style.RESET_ALL}')

    def check_peid_signatures(self):
        try:
            self.__print('[pack]:')

            sig_path = os.path.join(os.getcwd() + "\\UserDB.TXT")
            with open(sig_path, 'rt') as f:
                sig_data = f.read()
                signatures = peutils.SignatureDatabase(data=sig_data)
            signs = signatures.match(self.pe, ep_only=True)

            if signs is None:
                print(f'{Fore.BLUE}[{self.pid}][pack]: pack not detected{Style.RESET_ALL}')
                self.__print('  [-] not detected')
            else:
                danger_counter.add(self.pid, const.PACKER_POINT)
                danger_counter.add_details(self.pid, const.PACK)
                print(f'{Fore.RED}[{self.pid}][pack]: file may be packed{Style.RESET_ALL}')
                for s in signs:
                    self.__print('  [!]', s)
        finally:
            return

    def check_imported_symbols(self):
        try:
            self.__print('[import]:')
            imports = []
            for entry in getattr(self.pe, "DIRECTORY_ENTRY_IMPORT", []):
                for imported_symbol in entry.imports:
                    if imported_symbol.name is not None:
                        name = imported_symbol.name.decode("utf-8")
                        if name is not None and not name.startswith('_'):
                            imports.append(name)

            if len(imports) == 0:
                self.__print('  [-] no imported')
            else:
                for i in imports:
                    if i in const.alerts:
                        danger_counter.add(self.pid, const.SUSPICIOUS_IMPORT_POINT)
                        danger_counter.add_details(self.pid, const.SUSPICIOUS_IMPORT)
                        print(f'{Fore.RED}[{self.pid}][imports]: \'{i}\'{Style.RESET_ALL}')
                        self.__print(f'  [!] {i}')
                    else:
                        self.__print(f'  [-] {i}')
        finally:
            return

    def has_cert(self):
        self.__print('[signature]:')
        if not self.signed:
            self.__print('  [!] no signature')
            print(f'{Fore.RED}[{self.pid}][signature]: no signature{Style.RESET_ALL}')
            danger_counter.add(self.pid, const.NO_SIGNATURE_POINT)
            danger_counter.add_details(self.pid, const.NO_SIGNATURE)
        else:
            self.__print('  [-] has valid signature')

    def __print(self, *args):
        print(*args, file=self.output_file)


class Dump:
    def __init__(self, pid):
        self.pid = pid
        self.path_dump = None
        self.path_dir = f'C:\\tasks\\analysis\\{self.pid}\\dump'
        self.path_bdb_64 = "C:\\tasks\\exe\\pd64.exe"
        self.path_bdb_32 = "C:\\tasks\\exe\\pd32.exe"
        os.mkdir(self.path_dir)

    def get_dump(self):
        cmd64 = self.path_bdb_64 + " -pid " + str(self.pid) + ' -o ' + self.path_dir + " 1> temp.txt 2>null "
        try:
            os.system(cmd64)
        except:
            return

    def get_exe(self):
        for file in os.listdir(self.path_dir):
            if file[-4:] == ".exe":
                self.path_dump = self.path_dir + '\\' + file
                break
        else:
            self.path_dump = None
        return self.path_dump


def compare_bin(pid, path_1, path_2):
    if path_1 is None or path_2 is None:
        return None

    pe_exe = pefile.PE(path_1)
    pe_dump = pefile.PE(path_2)
    os.mkdir(f'analysis/{pid}/diff')

    count = 0
    for i, (section1, section2) in enumerate(zip(pe_exe.sections, pe_dump.sections)):
        data_in_disk = section1.get_data()
        data_in_dump = section2.get_data()

        if data_in_disk != data_in_dump:
            count += 1
            print(f'{Fore.RED}[{pid}][compare section]: executable process sections are different from file sections ' +
                  f'(section {section1.Name.decode("utf-8")[:-3]}, {section2.Name.decode("utf-8")[:-3]}){Style.RESET_ALL}')
        else:
            print(f'{Fore.BLUE}[{pid}][compare section]: executable process sections are same from file sections ' +
                  f'(section {section1.Name.decode("utf-8")[:-3]}, {section2.Name.decode("utf-8")[:-3]}){Style.RESET_ALL}')
        get_diff(pid, section1, section2)

    # danger_counter.add_details(pid, const.DIFFERENT_SECTION + f' {round(count / len(pe_exe.sections), 3)}%')


def get_diff(pid, section_1, section_2):
    file = f'analysis/{pid}/diff/{pid}{section_1.Name.decode("utf-8")}'
    file = file.replace('\0', '')

    printable_assembler_exe = ""
    for i in md.disasm(section_1.get_data(), 0):
        printable_assembler_exe += "0x%x:\t%s\t%s\n" % (i.address, i.mnemonic, i.op_str)

    printable_assembler_dump = ""
    for i in md.disasm(section_2.get_data(), 0):
        printable_assembler_dump += "0x%x:\t%s\t%s\n" % (i.address, i.mnemonic, i.op_str)

    diff = differ.compare(printable_assembler_dump.splitlines(), printable_assembler_exe.splitlines())

    with open(file, 'w') as f:
        f.write("\n".join(diff))
